#ifndef MSET_MESH_COMP
#define MSET_MESH_COMP

//random mesh attribute access

struct	Vertex
{
	vec3	position;
	vec3	tangent;
	vec3	bitangent;
	vec3	normal;
	vec3	gnormal;
	vec2	texcoord;
	vec2	texcoord2;
	vec4	color;
};

USE_RAWBUFFER(bMeshVertices);
USE_RAWBUFFER(bMeshIndices);
uniform uint uMeshIndices16bit;
uniform uint uMeshTriangleOffset;

#ifdef MESH_VERTEX_COLOR
USE_RAWBUFFER(bMeshVertexColors);
uniform uint uMeshVertexColors;
#endif

vec3	unpackVec( uint p )
{
	vec3 r;
	float c = (2.0/1022.0);
	r.x = float((p      ) & 0x3FF) * c - 1.0;
	r.y = float((p >> 10) & 0x3FF) * c - 1.0;
	r.z = float((p >> 20) & 0x3FF) * c - 1.0;
	return r;
}

Vertex	loadVertex( uint index )
{
	uint vindex = index << 3;
	uint4 line1 = rawLoad4(bMeshVertices,vindex);
	uint4 line2 = rawLoad4(bMeshVertices,vindex+4);

	Vertex v;
	v.position = asfloat(line1.xyz);
	v.tangent = unpackVec(line1.w);
	v.bitangent = unpackVec(line2.x);
	v.normal = unpackVec(line2.y);
	v.texcoord = asfloat(line2.zw);

	v.color = vec4(1.0,1.0,1.0,1.0);
	v.texcoord2 = v.texcoord;

	#ifdef MESH_VERTEX_COLOR
	if( uMeshVertexColors )
	{
		uint c = rawLoad( bMeshVertexColors, index );
		v.color.r = float((c    ) & 0xFF);
		v.color.g = float((c>> 8) & 0xFF);
		v.color.b = float((c>>16) & 0xFF);
		v.color.a = float((c>>24)       );
		v.color *= 1.0/255.0;
	}
	#endif

	return v;
}

uint3	loadTriangle( uint index )
{
	index += uMeshTriangleOffset;
	index += index + index;
	if( uMeshIndices16bit )
	{
		//16-bit load
		uint r = index & 1;
		index >>= 1;
		uint2 words = rawLoad2( bMeshIndices, index );
		return	r > 0 ?
				uint3( words.x >> 16, words.y & 0xFFFF, words.y >> 16 ) :
				uint3( words.x & 0xFFFF, words.x >> 16, words.y & 0xFFFF );
	}
	else
	{
		//32-bit load
		return rawLoad3( bMeshIndices, index );
	}
}

#endif