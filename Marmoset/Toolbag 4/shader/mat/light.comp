#ifndef LIGHT_COMP
#define LIGHT_COMP

#define LIGHT_FLAG_CAST_SHADOWS		(1<<24)
#define LIGHT_FLAG_GEL_GRAYSCALE	(1<<25)

uniform int		uLightCountTotal;
uniform int		uLightCountPoint;
uniform uint2	uLightAreaMask;
uniform vec2	uLightChoosePDF; // { pdfChooseSky, pdfChooseDynamic }

struct	LightData
{
	vec4	positionTileRadius;	// { x32, y32, z32, gelTile16, radius16 }
	uint4	sizeAxisXY;			// { w16, h16, axisXY48, axisY48 }
	uint2	colorFlagsBright;	// { flags8, r8, g8, b8, brightness32 }
	uint2	spotGelTexture;		// { spotSharpness16, spotSinAngle16, gelTextureIndex32 }
};
USE_STRUCTUREDBUFFER(LightData,bLightData);
USE_BUFFER(mat4,bLightProjections);
#if CPR_D3D_SM >= 60 || defined(CPR_METAL)
USE_GLOBAL_TEXTURE2D(tLightGels,100);
#endif
USE_SAMPLER(sLightGelSampler);
struct	LightParams
{
	//all light types
	vec3	color;			// "colour"
	vec3	direction;		// normalized direction vector
	vec3	size;			// width, height, radius
	vec3	axisX, axisY;	// 2D area axes
	vec3	axisZ;			// front orientation axis
	bool	castShadows;	// should this light cast shadows?
	//point lights only
	vec3	position;		// world space position
	vec3	toSource;		// vector from shading point to light
	float	distance;		// distance to light
	float	invDistance2;	// 1/distance^2 to light
	float	fade;			// fade due to spot or side check
};

float		pointLightFade( LightParams p, float spotSinAngle, float spotSharpness )
{
	float LdotZ	= saturate( dot( p.direction, p.axisZ ) );
	float fade  = 1.0;
	if( spotSinAngle > 0.0 )
	{
		//spot light
		float spotSinDirection = sqrt( saturate(1.0 - LdotZ*LdotZ) );
		fade = saturate( spotSharpness - spotSharpness*spotSinDirection/spotSinAngle );
	}
	else if( spotSharpness > 0.0 )
	{
		//single-sided omni light
		fade = LdotZ > 0.0 ? 1.0 : 0.0;
	}
	return fade;
}

LightParams computePointLightParams( uint i, vec3 origin )
{
	LightData data = bLightData[i];

	LightParams p;
	p.position = data.positionTileRadius.xyz;
	
	uint sizeWH = data.sizeAxisXY.x;
	p.size.y = f16tof32( sizeWH );
	p.size.x = f16tof32( sizeWH>>16 );
	
	uint tileRadius = asuint( data.positionTileRadius.w );
	p.size.z = f16tof32( tileRadius );

	uint axisXY0 = data.sizeAxisXY.y;
	uint axisXY1 = data.sizeAxisXY.z;
	uint axisZZ  = data.sizeAxisXY.w;
	p.axisX.x = f16tof32( axisXY0 );
	p.axisX.y = f16tof32( axisXY0>>16 );
	p.axisY.x = f16tof32( axisXY1 );
	p.axisY.y = f16tof32( axisXY1>>16 );
	p.axisX.z = f16tof32( axisZZ );
	p.axisY.z = f16tof32( axisZZ>>16 );
	p.axisZ   = cross( p.axisX, p.axisY );

	uint  colorFlags = data.colorFlagsBright.x;
	float brightness = asfloat( data.colorFlagsBright.y );
	p.color.b = ( (colorFlags    ) & 0xFF );
	p.color.g = ( (colorFlags>>8 ) & 0xFF );
	p.color.r = ( (colorFlags>>16) & 0xFF );
	p.color  *= brightness;
	p.castShadows = colorFlags & LIGHT_FLAG_CAST_SHADOWS;

	p.toSource = p.position - origin;
	float d2 = dot( p.toSource, p.toSource );
	float invDistance = rsqrt( d2 );
	p.distance = sqrt( d2 );
	p.direction = p.toSource * invDistance;
	p.invDistance2 = invDistance * invDistance;
		
	//spot params & fade
	uint  spotParams    = data.spotGelTexture.x;
	float spotSinAngle  = f16tof32( spotParams );
	float spotSharpness = f16tof32( spotParams>>16 );
	p.fade   = pointLightFade( p, spotSinAngle, spotSharpness );
	p.color *= p.fade;

#ifdef SceneHasPointLights_WithGels
	//gel
	uint gelTextureIndex = data.spotGelTexture.y;
	if( gelTextureIndex != uint(~0) )
	{
		//projective texture coordinates
		vec4  projOrigin = mulPoint( bLightProjections[i], origin );
		float projDepth  = length( projOrigin.xyz );
		vec2  projCoord	 = projOrigin.xy / ( spotSinAngle > 0.0 ? projOrigin.w : projDepth );
		if( spotSinAngle < 0.0 ) // Omni
		{
			projCoord.y = 1.0f - projCoord.y;
		}

		//gel params
		float gelTile = f16tof32( tileRadius>>16 );
		bool  gelGrayscale = colorFlags & LIGHT_FLAG_GEL_GRAYSCALE;
	#ifdef RENDERTARGET_Y_DOWN
		vec4  gelTileCoord = vec4( gelTile, -gelTile, gelTile, 0.0 );
	#else
		vec4  gelTileCoord = vec4( gelTile, gelTile, 0.0, 0.0 );
	#endif

	#if CPR_D3D_SM >= 60 || defined(CPR_METAL)
		//gel sample
		vec2 uv  = projCoord * gelTileCoord.xy + gelTileCoord.zw;
		vec3 gel = textureWithSamplerLod( resourceByIndex(tLightGels,gelTextureIndex), sLightGelSampler, uv, 0.0 ).rgb;
		gel = gelGrayscale ? gel.rrr : gel;
		p.color *= gel;
	#endif
	}
#endif
	
	return p;
}

LightParams computeDistantLightParams( uint i, vec3 origin )
{
	LightData data = bLightData[i];

	LightParams p;
	p.direction = data.positionTileRadius.xyz;
	
	uint sizeWH = data.sizeAxisXY.x;
	p.size.y = f16tof32( sizeWH );
	p.size.x = f16tof32( sizeWH>>16 );

	uint tileRadius = asuint( data.positionTileRadius.w );
	p.size.z = f16tof32( tileRadius );
	
	uint axisXY0 = data.sizeAxisXY.y;
	uint axisXY1 = data.sizeAxisXY.z;
	uint axisZZ  = data.sizeAxisXY.w;
	p.axisX.x = f16tof32( axisXY0 );
	p.axisX.y = f16tof32( axisXY0>>16 );
	p.axisY.x = f16tof32( axisXY1 );
	p.axisY.y = f16tof32( axisXY1>>16 );
	p.axisX.z = f16tof32( axisZZ );
	p.axisY.z = f16tof32( axisZZ>>16 );
	p.axisZ   = cross( p.axisX, p.axisY );
	
	uint  colorFlags = data.colorFlagsBright.x;
	float brightness = asfloat( data.colorFlagsBright.y );
	p.color.b = ( (colorFlags    ) & 0xFF );
	p.color.g = ( (colorFlags>>8 ) & 0xFF );
	p.color.r = ( (colorFlags>>16) & 0xFF );
	p.color  *= brightness;
	p.castShadows = colorFlags & LIGHT_FLAG_CAST_SHADOWS;

	p.toSource = p.direction;
	p.position = vec3(0.0, 0.0, 0.0);
	p.distance = INFINITY;
	p.invDistance2 = 0.0;
	p.fade = 1.0;

#ifdef SceneHasDistantLights_WithGels
	//gel
	uint gelTextureIndex = data.spotGelTexture.y;
	if( gelTextureIndex != uint(~0) )
	{
		//projective texture coordinates
		vec4 projOrigin	= mulPoint( bLightProjections[i], origin );
		vec2 projCoord  = projOrigin.xy / projOrigin.w;
	
		//gel params
		float gelTile = f16tof32( tileRadius>>16 );
		bool  gelGrayscale = colorFlags & LIGHT_FLAG_GEL_GRAYSCALE;
	#ifdef RENDERTARGET_Y_DOWN
		vec4  gelTileCoord = vec4( gelTile, -gelTile, gelTile, 0.0 );
	#else
		vec4  gelTileCoord = vec4( gelTile, gelTile, 0.0, 0.0 );
	#endif

	#if CPR_D3D_SM >= 60 || defined(CPR_METAL)
		//gel sample
		vec2 uv  = projCoord * gelTileCoord.xy + gelTileCoord.zw;
		vec3 gel = textureWithSamplerLod( resourceByIndex(tLightGels,gelTextureIndex), sLightGelSampler, uv, 0.0 ).rgb;
		gel = gelGrayscale ? gel.rrr : gel;
		p.color *= gel;
	#endif
	}
#endif

	return p;
}

#endif
