#include "../common/util.sh"
#include "../mat/state.vert"


USE_INTERLOCKED_BUFFER(rawMeshBuffer, 0);

USE_BUFFER(uint, fusedIndexMapIN);
USE_BUFFER(uint, triangleIndicesIN);
USE_BUFFER(uint, fusedVertexValenceMapIN);

uniform uint	uNumVertices;

vec3 getSrcVertex(uint id)
{
	vec3 v = asfloat(interlockedLoad3(rawMeshBuffer, id*8));
	return v;
}

vec2 getSrcUV(uint id)
{
	vec2 v = asfloat(interlockedLoad2(rawMeshBuffer, (id*8)+6));
	return v;
}

uint packVector( vec3 normal )
{
	uint packed;

	float nx = ((normal.x*0.5) + 0.5) * 1022.f;
	float ny = ((normal.y*0.5) + 0.5) * 1022.f;
	float nz = ((normal.z*0.5) + 0.5) * 1022.f;

	int ux = int(nx);
	int uy = int(ny);
	int uz = int(nz);

	packed  = ux;
	packed |= uy << 10;
	packed |= uz << 20;

	return packed;
}

float cornerWeight(vec3 v1, vec3 v2)
{
	v1 = normalize(v1);
	v2 = normalize(v2);
	float weight = 1.0 - dot(v1, v2);
	if( weight < 0 )//angle past 90 degrees
	{
		weight = 1.0-weight;//will be > 1
	}
	return weight;
}

uint3 gatherSrcTangentBitangentNormal(uint vertexIndex)
{

	vec3 normal;
	normal.x = 0;
	normal.y = 0;
	normal.z = 0;

	vec3 tangent;
	tangent.x = 0;
	tangent.y = 0;
	tangent.z = 0;

	vec3 bitangent;
	bitangent.x = 0;
	bitangent.y = 0;
	bitangent.z = 0;

	uint fusedIndex = fusedIndexMapIN[vertexIndex];

	uint numSrcTriangles = fusedVertexValenceMapIN[(fusedIndex*2)+0];
	uint tableStartIndex = fusedVertexValenceMapIN[(fusedIndex*2)+1]+(uNumVertices*2);


	for( uint i=0; i<numSrcTriangles; i++ )
	{
		uint triangleIndex = fusedVertexValenceMapIN[tableStartIndex+i];

		vec3 triangleNormal;
		vec3 triangleTangent;
		vec3 triangleBitangent;

		uint a = triangleIndicesIN[(triangleIndex*3)+0];
		uint b = triangleIndicesIN[(triangleIndex*3)+1];
		uint c = triangleIndicesIN[(triangleIndex*3)+2];
		vec3 va = getSrcVertex(a);
		vec3 vb = getSrcVertex(b);
		vec3 vc = getSrcVertex(c);
		vec3 vab = va-vb;
		vec3 vac = va-vc;

		uint cornerIndex = 0;
		if( fusedIndex == fusedIndexMapIN[b] )
		{ cornerIndex = 1; }
		else if( fusedIndex == fusedIndexMapIN[c] )
		{ cornerIndex = 2; }

		triangleNormal.x = ((vab.y * vac.z) - (vab.z * vac.y));
		triangleNormal.y = ((vab.z * vac.x) - (vab.x * vac.z));
		triangleNormal.z = ((vab.x * vac.y) - (vab.y * vac.x));

		float tlen = sqrt((triangleNormal.x*triangleNormal.x)+(triangleNormal.y*triangleNormal.y)+(triangleNormal.z*triangleNormal.z));
		if( tlen != 0 )
		{
			float weight = 0;

			if( cornerIndex == 0 )
			{ weight = cornerWeight(vb-va, vc-va); }
			else if( cornerIndex == 1 )
			{ weight = cornerWeight(va-vb, vc-vb); }
			else if( cornerIndex == 2 )
			{ weight = cornerWeight(va-vc, vb-vc); }
			else
			{
				//not a direct match for index - still ok for non-fused normals mode
			}

			float scale = (1.0 / tlen) * weight;
			triangleNormal.x *= scale;
			triangleNormal.y *= scale;
			triangleNormal.z *= scale;

			vec3 q1 = vb-va;
			vec3 q2 = vc-va;

			vec2 uva = getSrcUV(a);
			vec2 uvb = getSrcUV(b);
			vec2 uvc = getSrcUV(c);

			float s1 = uvb.x - uva.x;
			float s2 = uvc.x - uva.x;
			float t1 = uvb.y - uva.y;
			float t2 = uvc.y - uva.y;
			float denom = (s1*t2 - s2*t1);
			float c = (denom == 0.f) ? 1.f : (1.f / denom);
	
			vec3 t;
			vec3 b;
			t.x = ( q1.x*t2 - q2.x*t1 );
			t.y = ( q1.y*t2 - q2.y*t1 );
			t.z = ( q1.z*t2 - q2.z*t1 );
			b.x = ( q2.x*s1 - q1.x*s2 );
			b.y = ( q2.y*s1 - q1.y*s2 );
			b.z = ( q2.z*s1 - q1.z*s2 );

			t = normalize(t);
			b = normalize(b);
			tangent += t;
			bitangent += b;
		}

		normal += triangleNormal;
	}

	float slen = (normal.x*normal.x)+(normal.y*normal.y)+(normal.z*normal.z);
	if( slen != 0 )
	{ normal *= rsqrt(slen); }

	//fast preview mode normals only

	slen = (tangent.x*tangent.x)+(tangent.y*tangent.y)+(tangent.z*tangent.z);
	if( slen != 0 )
	{ tangent *= rsqrt(slen); }

	slen = (bitangent.x*bitangent.x)+(bitangent.y*bitangent.y)+(bitangent.z*bitangent.z);
	if( slen != 0 )
	{ bitangent *= rsqrt(slen); }


	float NdotT = (tangent.x*normal.x + tangent.y*normal.y + tangent.z*normal.z);
	tangent.x -= NdotT * normal.x;
	tangent.y -= NdotT * normal.y;
	tangent.z -= NdotT * normal.z;

	slen = tangent.x*tangent.x + tangent.y*tangent.y + tangent.z*tangent.z;
	if( slen != 0.f )
	{
		float L = rsqrt( slen );
		tangent.x *= L; tangent.y *= L; tangent.z *= L;
	}
	else
	{
		if( normal.x == 0.f )
		{ tangent.x = 1.f; tangent.y = tangent.z = 0.f; }
		else if( normal.y == 0.f )
		{ tangent.y = 1.f; tangent.x = tangent.z = 0.f; }
		else if( normal.z == 0.f )
		{ tangent.z = 1.f; tangent.x = tangent.y = 0.f; }
		else
		{
			tangent.x = tangent.y = 1.f;
			tangent.z = (-normal.x-normal.y) / normal.z;
			slen = (tangent.x*tangent.x)+(tangent.y*tangent.y)+(tangent.z*tangent.z);
			if( slen != 0 )
			{ tangent *= rsqrt(slen); }
		}
	}
			
	float NdotB = (bitangent.x*normal.x + bitangent.y*normal.y + bitangent.z*normal.z);
	float TdotB = (bitangent.x*tangent.x + bitangent.y*tangent.y + bitangent.z*tangent.z);
	bitangent.x -= NdotB * normal.x + TdotB * tangent.x;
	bitangent.y -= NdotB * normal.y + TdotB * tangent.y;
	bitangent.z -= NdotB * normal.z + TdotB * tangent.z;
	slen = tangent.x*tangent.x + tangent.y*tangent.y + tangent.z*tangent.z;
	if( slen != 0.f )
	{
		float L = rsqrt( slen );
		bitangent.x *= L; bitangent.y *= L; bitangent.z *= L;
	}
	else
	{
		bitangent.x = ((normal.y * tangent.z) - (normal.z * tangent.y));
		bitangent.y = ((normal.z * tangent.x) - (normal.x * tangent.z));
		bitangent.z = ((normal.x * tangent.y) - (normal.y * tangent.x));
	}

	uint3 result;
	result.x = packVector(tangent);
	result.y = packVector(bitangent);
	result.z = packVector(normal);

	return result;
}

uint gatherSrcNormal(uint vertexIndex)
{

	vec3 normal;
	normal.x = 0;
	normal.y = 0;
	normal.z = 0;

	uint fusedIndex = fusedIndexMapIN[vertexIndex];

	uint numSrcTriangles = fusedVertexValenceMapIN[(fusedIndex*2)+0];
	uint tableStartIndex = fusedVertexValenceMapIN[(fusedIndex*2)+1]+(uNumVertices*2);

	for( uint i=0; i<numSrcTriangles; i++ )
	{
		uint triangleIndex = fusedVertexValenceMapIN[tableStartIndex+i];

		vec3 triangleNormal;
		vec3 triangleTangent;
		vec3 triangleBitangent;

		uint a = triangleIndicesIN[(triangleIndex*3)+0];
		uint b = triangleIndicesIN[(triangleIndex*3)+1];
		uint c = triangleIndicesIN[(triangleIndex*3)+2];
		vec3 va = getSrcVertex(a);
		vec3 vb = getSrcVertex(b);
		vec3 vc = getSrcVertex(c);
		vec3 vab = va-vb;
		vec3 vac = va-vc;

		uint cornerIndex = 0;
		if( fusedIndex == fusedIndexMapIN[b] )
		{ cornerIndex = 1; }
		else if( fusedIndex == fusedIndexMapIN[c] )
		{ cornerIndex = 2; }

		triangleNormal.x = ((vab.y * vac.z) - (vab.z * vac.y));
		triangleNormal.y = ((vab.z * vac.x) - (vab.x * vac.z));
		triangleNormal.z = ((vab.x * vac.y) - (vab.y * vac.x));

		float tlen = sqrt((triangleNormal.x*triangleNormal.x)+(triangleNormal.y*triangleNormal.y)+(triangleNormal.z*triangleNormal.z));
		if( tlen != 0 )
		{
			float weight = 0;

			if( cornerIndex == 0 )
			{ weight = cornerWeight(vb-va, vc-va); }
			else if( cornerIndex == 1 )
			{ weight = cornerWeight(va-vb, vc-vb); }
			else if( cornerIndex == 2 )
			{ weight = cornerWeight(va-vc, vb-vc); }
			else
			{
				//not a direct match for index - still ok for non-fused normals mode
			}

			float scale = (1.0 / tlen) * weight;
			triangleNormal.x *= scale;
			triangleNormal.y *= scale;
			triangleNormal.z *= scale;
		}

		normal += triangleNormal;
	}

	float slen = (normal.x*normal.x)+(normal.y*normal.y)+(normal.z*normal.z);
	if( slen != 0 )
	{ normal *= rsqrt(slen); }

	return packVector(normal);
}

void writePackedTangentBitangentNormal(uint3 tbn, uint id)
{
	uint dstIndex = (id*8)+3;
	interlockedStore3(rawMeshBuffer, dstIndex, tbn);
}

void writePackedNormal(uint n, uint id)
{
	uint dstIndex = (id*8)+5;
	interlockedStore(rawMeshBuffer, dstIndex, n);
}

COMPUTE(256,1,1)
{
	uint id = DISPATCH_THREAD_ID.x + (DISPATCH_THREAD_ID.y * 65535);
    if( id < uNumVertices )
    {
		writePackedTangentBitangentNormal(gatherSrcTangentBitangentNormal(id), id);
	}
}

