#ifndef MSET_BUFFERS_COMP
#define MSET_BUFFERS_COMP

#define RT_COUNTER_LIGHTRAYS        0
#define RT_COUNTER_SCATTERINGRAYS   4
#define RT_COUNTER_INDIRECTRAYS     8
#define RT_COUNTER_INDIRECTHITS     12

#define RT_RAYFLAG_MEDIUM			0x80000000
#define RT_RAYFLAG_MEDIUMSCATTER	0x40000000
#define RT_RAYFLAG_SUBSURFACE		0x20000000
#define RT_RAYFLAG_SHADOWCATCHER	0x10000000
#define RT_RAYFLAG_CULL_BACKFACES	0x08000000
#define RT_RAYFLAG_MASK				0xF8000000
#define RT_INDEX_MASK				(~uint(RT_RAYFLAG_MASK))

#define RT_PATHFLAG_BIT				0x80000000

#if defined(TypedObjectIndexLoad8)
    #if defined(CPR_METAL)
        #define USE_OBJECTINDEXBUFFER(name) USE_TYPEDBUFFER(uint8_t,name)
    #else
        #define USE_OBJECTINDEXBUFFER(name) USE_TYPEDBUFFER(uint,name)
    #endif
#elif defined(TypedObjectIndexLoad16)
    #if defined(CPR_METAL)
        #define USE_OBJECTINDEXBUFFER(name) USE_TYPEDBUFFER(uint16_t,name)
    #else
        #define USE_OBJECTINDEXBUFFER(name) USE_TYPEDBUFFER(uint,name)
    #endif
#else
    #define USE_OBJECTINDEXBUFFER(name) USE_BUFFER(uint,name)
#endif

#if defined(TypedObjectIndexStore8)
    #if defined(CPR_METAL)
        #define USE_LOADSTORE_OBJECTINDEXBUFFER(name,id) USE_LOADSTORE_TYPEDBUFFER(uint8_t,name,id)
    #else
        #define USE_LOADSTORE_OBJECTINDEXBUFFER(name,id) USE_LOADSTORE_TYPEDBUFFER(uint,name,id)
    #endif
#elif defined(TypedObjectIndexStore16)
    #if defined(CPR_METAL)
        #define USE_LOADSTORE_OBJECTINDEXBUFFER(name,id) USE_LOADSTORE_TYPEDBUFFER(uint16_t,name,id)
    #else
        #define USE_LOADSTORE_OBJECTINDEXBUFFER(name,id) USE_LOADSTORE_TYPEDBUFFER(uint,name,id)
    #endif
#else
    #define USE_LOADSTORE_OBJECTINDEXBUFFER(name,id) USE_LOADSTORE_BUFFER(uint,name,id)
#endif

uniform uint uRTBufferStride;
#define RT_BUFFER0(buf,index) buf[index]
#define RT_BUFFER1(buf,index) buf[uRTBufferStride+index]
#define RT_BUFFER2(buf,index) buf[mad(2,uRTBufferStride,index)]

uint packUnitFloat( float v )
{
    return uint(v * 65535.0)/* & 0xFFFF */;
}

float unpackUnitFloat( uint p )
{
    return float(p /*& 0xFFFF*/) * (1.0/65535.0);
}

uint packUnitVec2f( vec2 v )
{
    return (packUnitFloat(v.x) & 0xFFFF) | (packUnitFloat(v.y) << 16);
}

vec2 unpackUnitVec2f( uint p )
{
    return vec2(unpackUnitFloat(p & 0xFFFF), unpackUnitFloat(p >> 16));
}

uint2 packVec3f( vec3 v )
{
	uint2 p;
    p.x = f32tof16(v.x) | (f32tof16(v.y)<<16);
    p.y = asuint(v.z);
	return p;
}

vec3 unpackVec3f( uint2 p )
{
	return vec3( f16tof32(p.x), f16tof32(p.x>>16), asfloat(p.y) );
}

uint2 packVec4f( vec4 v )
{
	uint2 p;
	p.x = (f32tof16(v.x)<<16) | f32tof16(v.y);
	p.y = (f32tof16(v.z)<<16) | f32tof16(v.w);
	return p;
}

vec4 unpackVec4f( uint2 p )
{
	vec4 v;
	v.x = f16tof32(p.x>>16);
	v.y = f16tof32(p.x    );
	v.z = f16tof32(p.y>>16);
	v.w = f16tof32(p.y    );
	return v;
}

uint3 packVec2x3f( vec3 v1, vec3 v2 )
{
    uint3 p;
    p.x = f32tof16(v1.x) | (f32tof16(v1.y)<<16);
    p.y = f32tof16(v1.z) | (f32tof16(v2.x)<<16);
    p.z = f32tof16(v2.y) | (f32tof16(v2.z)<<16);
    return p;
}

void unpackVec2x3f( uint3 p, out vec3 v1, out vec3 v2 )
{
    v1 = vec3( f16tof32(p.x),     f16tof32(p.x>>16), f16tof32(p.y) );
    v2 = vec3( f16tof32(p.y>>16), f16tof32(p.z),     f16tof32(p.z>>16) );
}

void addPackedVec4f( inout uint2 p, vec3 v )
{
	uint x16 = f32tof16(f16tof32(p.x>>16) + v.x)<<16;
	uint y16 = f32tof16(f16tof32(p.x    ) + v.y);
	uint z16 = f32tof16(f16tof32(p.y>>16) + v.z)<<16;
	uint w16 = p.y & 0xFFFF;
	p.x = x16 | y16;
	p.y = z16 | w16;
}

void addPackedVec4fW( inout uint2 p, float w )
{
	uint z16 = p.y & 0xFFFF0000;
	uint w16 = f32tof16(f16tof32(p.y) + w);
	p.y = z16 | w16;
}

void mulPackedVec4fSetW( inout uint2 p, float s, float w )
{
    uint x16 = f32tof16(f16tof32(p.x>>16) * s)<<16;
    uint y16 = f32tof16(f16tof32(p.x    ) * s);
    uint z16 = f32tof16(f16tof32(p.y>>16) * s)<<16;
	uint w16 = f32tof16(w);
    p.x = x16 | y16;
    p.y = z16 | w16;
}

#ifdef CPR_METAL
void addPackedVec4f( device uint2& p, vec3 v )
{
    uint x16 = f32tof16(f16tof32(p.x>>16) + v.x)<<16;
    uint y16 = f32tof16(f16tof32(p.x    ) + v.y);
    uint z16 = f32tof16(f16tof32(p.y>>16) + v.z)<<16;
    uint w16 = p.y & 0xFFFF;
    p.x = x16 | y16;
    p.y = z16 | w16;
}

void addPackedVec4fW( device uint2& p, float w )
{
    uint z16 = p.y & 0xFFFF0000;
    uint w16 = f32tof16(f16tof32(p.y) + w);
    p.y = z16 | w16;
}

void mulPackedVec4fSetW( device uint2& p, float s, float w )
{
    uint x16 = f32tof16(f16tof32(p.x>>16) * s)<<16;
    uint y16 = f32tof16(f16tof32(p.x    ) * s);
    uint z16 = f32tof16(f16tof32(p.y>>16) * s)<<16;
	uint w16 = f32tof16(w);
    p.x = x16 | y16;
    p.y = z16 | w16;
}
#endif

/*
    PAYLOAD FORMATS
    - Radiance [16b]
        0: vec4( radiance.rgba )
	- PathState [2x32b]
		0 : vec4( throughput.rgb [+pathFlags], f32tof16(subsurfaceRadius)<<16 | f32tof16(pathMaxGloss) )
		1a: vec4( packVec2x3f(mediumExtinction.rgb, mediumScatter.rgb).xyz, mediumAnisotropy )
		1b: vec4( subsurfaceOrigin.xyz, packUnitVectorOct( subsurfaceNormal ) )
    - DirectRay [32b]
        0: vec4( origin.xyz, flags|radianceIndex )
        1: vec4( packVec2x3f(direction.xyz, rayRadiance.rgb).xyz, maxT )
    - IndirectRay [32b]
        0: vec4( origin.xyz, flags|radianceIndex )
        1: vec4( packVec2x3f(direction.xyz, rayRadiance.rgb).xyz, misLightDistance )
    - IndirectRayVolumetric [32b]
        0: vec4( origin.xyz, flags|radianceIndex )
        1: vec4( direction.xyz, rayObjectIndex )
    - IndirectRaySubsurfaceDiffusion [32b]
        0: vec4( origin.xyz, flags|radianceIndex )
        1: vec4( packVec3f(direction.xyz).xy, rayMaxT, rayObjectIndex )
    - IndirectHit [32b]
        0: vec4( flags|radianceIndex, asfloat(pathIndex), asfloat(triangleIndex), packUnitVec2f(triangleCoord.xy) )
		1: vec4( packVec2x3f(direction.xyz, rayThroughput.rgb), hitT/invHitCount )
 */

#endif
