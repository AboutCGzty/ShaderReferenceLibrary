#include "../../common/const.sh"
#include "../../common/util.sh"
#include "../../common/rng.comp"

struct BVHNode
{
	vec4	boundsX;
	vec4	boundsY;
	vec4	boundsZ;
	uint2	submeshIndex;
	uint2	nodeRefIndex;
};

struct BVHMesh
{
	mat3x4	inverseTransform;
	uint	nodeOffset;
	uint	vertexOffset;
	uint	indexOffset;
	uint	flags;
};
#define BVHMESH_FLAG_OPAQUE			1
#define BVHMESH_FLAG_SHADOW_CASTER	2
#define BVHMESH_FLAG_CAMERA_VISIBLE	4
#define BVHMESH_FLAG_CULL_BACKFACES	8

struct BVHSubmesh
{
	uint	meshIndex;
	uint	submeshOffset;
};

struct BVHVertex
{
	vec3	position;
	uint	texcoord;
};

struct BVHTriangle
{
	vec3	v0, v1, v2;
	uint	t0, t1, t2;
};

USE_STRUCTUREDBUFFER(BVHNode,RT_TopLevelBVH);
USE_STRUCTUREDBUFFER(BVHNode,RT_BVHNodes);
USE_STRUCTUREDBUFFER(BVHSubmesh,RT_BVHSubmeshRefs);
#ifdef CPR_METAL
	USE_BUFFER(vec4,RT_BVHMeshRefs);
	USE_BUFFER(vec4,RT_Vertices);
#else
	USE_STRUCTUREDBUFFER(BVHMesh,RT_BVHMeshRefs);
	USE_STRUCTUREDBUFFER(BVHVertex,RT_Vertices);
#endif
USE_RAWBUFFER(RT_Indices);

#ifdef RT_TRACE_TRANSPARENCY
USE_TEXTURE2DARRAY(RT_TransparencyAtlas);
USE_RAWBUFFER(RT_TransparencyIndices);
#endif

struct Ray
{
	vec3 origin;
	vec3 direction;
	vec3 invDirection;
};

struct RayHit
{
	vec2  coords;
	float distance;
	uint  triangleIndex;
	uint  objectIndex;
#if defined(RT_TRACE_OBJECTFILTER)
	bool  objectFilter;
#endif
#if defined(RT_TRACE_SUBSURFACE_DIFFUSION)
	uint  hitIndices;
#endif
#if defined(RT_TRACE_TRANSPARENCY_DITHER)
	RNG rng;
#endif
};

Ray buildRay( vec3 origin, vec3 unitDir )
{
	Ray r;
	r.origin = origin;
	r.direction = unitDir;
	r.invDirection = rcpSafeInf( unitDir );
	return r;
}

void transformRay( mat3x4 m, inout Ray r )
{
	vec3 o = mul( m, vec4(r.origin, 1.0) ).xyz;
	vec3 d = mul( m, vec4(r.direction, 0.0) ).xyz;
	r = buildRay( o, d );
}

BVHMesh		loadMeshBVH( uint index )
{
#ifdef CPR_METAL
	//Metal aligns and pads mat3x4 type as 16 scalars,
	//which means BVHMesh needs to be manually constructed. -jdr
	index = index * 4;
	BVHMesh mesh;
	
	vec4 r0 = RT_BVHMeshRefs[index], r1 = RT_BVHMeshRefs[index+1], r2 = RT_BVHMeshRefs[index+2];
	mesh.inverseTransform = mat3x4(
		vec3( r0.x, r0.y, r0.z ),
		vec3( r0.w, r1.x, r1.y ),
		vec3( r1.z, r1.w, r2.x ),
		vec3( r2.y, r2.z, r2.w )
	);
	
	uint4 r3 = asuint( RT_BVHMeshRefs[index+3] );
	mesh.nodeOffset = r3.x;
	mesh.vertexOffset = r3.y;
	mesh.indexOffset = r3.z;
	mesh.flags = r3.w;

	return mesh;
#else
	return RT_BVHMeshRefs[index];
#endif
}

BVHVertex	loadVertexBVH( uint index )
{
#ifdef CPR_METAL
	//Metal aligns and pads vec3 types as vec4,
	//which means BVHVertex doesnt match the given layout in memory. -jdr
	vec4 r = RT_Vertices[index];
	BVHVertex v;
	v.position = r.xyz;
	v.texcoord = asuint( r.w );
	return v;
#else
	return RT_Vertices[index];
#endif
}

BVHTriangle loadTriangleBVH( uint index, BVHMesh mesh )
{
	uint3 indices = rawLoad3( RT_Indices, mad( 3, index, mesh.indexOffset ) );

	BVHTriangle t;
	BVHVertex v;

	v = loadVertexBVH(mesh.vertexOffset + indices.x);
	t.v0 = v.position;
	t.t0 = v.texcoord;

	v = loadVertexBVH(mesh.vertexOffset + indices.y);
	t.v1 = v.position;
	t.t1 = v.texcoord;

	v = loadVertexBVH(mesh.vertexOffset + indices.z);
	t.v2 = v.position;
	t.t2 = v.texcoord;

	return t;
}

bool intersectTriangleBVH( Ray ray, BVHTriangle t, inout RayHit hit )
{
	vec3 e1 = t.v1 - t.v0, e2 = t.v2 - t.v0;
	vec3 q = cross( ray.direction, e2 );

	float a = dot( e1, q );
	float invA = rcp(a);
	vec3 s = (ray.origin - t.v0);
	vec3 r = cross( s, e1 );

	float u = dot( s, q )*invA;
	float v = dot( r, ray.direction )*invA;
	float w = 1.0-u-v;

	HINT_FLATTEN
	if( a != 0.0 && u >= 0.0 && v >= 0.0 && w >= 0.0 )
	{
		hit.distance = dot( e2, r )*invA;
		hit.coords = vec2( u, v );
		return hit.distance > 0.0;
	}
	return false;
}

#ifdef RT_TRACE_TRANSPARENCY
#define TRANSPARENCY_SUBROUTINE_NONE	0x00
#define TRANSPARENCY_SUBROUTINE_CUTOUT	0x01
#define TRANSPARENCY_SUBROUTINE_DITHER	0x02
bool testTransparencyBVH( BVHTriangle t, inout RayHit hit, uint transparencyIndex )
{
	if( transparencyIndex > 0xFFFFFF )
	{
		vec2 tc = 
			  vec2( f16tof32(t.t0), f16tof32(t.t0>>16) ) * (1.0-hit.coords.x-hit.coords.y)
			+ vec2( f16tof32(t.t1), f16tof32(t.t1>>16) ) * hit.coords.x
			+ vec2( f16tof32(t.t2), f16tof32(t.t2>>16) ) * hit.coords.y;
		float alpha = texture2DArrayLod( RT_TransparencyAtlas, vec3( tc.x, tc.y, transparencyIndex & 0x00FFFFFF ), 0.0 ).r;

		uint subroutineIndex = transparencyIndex >> 24;
		#ifdef RT_TRACE_TRANSPARENCY_CUTOUT
		if( subroutineIndex == TRANSPARENCY_SUBROUTINE_CUTOUT )
		{
			return alpha > 0.49;
		}
		#endif
		#ifdef RT_TRACE_TRANSPARENCY_DITHER
		if( subroutineIndex == TRANSPARENCY_SUBROUTINE_DITHER )
		{
			float noise = rngNextFloat( hit.rng );
			return alpha >= noise;
		}
		#endif
	}
	return true;
}
#endif

BVH_RESULT intersectLeafBVH( Ray r, inout RayHit hit, BVHMesh mesh, uint objectIndex, uint triangleIndex )
{
	#ifdef RT_TRACE_OBJECTFILTER
	if( hit.objectFilter && hit.objectIndex != objectIndex )
	{
		BVH_RETURN_MISS;
	}
	#endif
	
	RayHit h = hit;
	h.objectIndex   = objectIndex;
	h.triangleIndex = triangleIndex;

	BVHTriangle t = loadTriangleBVH( h.triangleIndex, mesh );

	#ifdef RT_TRACE_TRANSPARENCY
	uint transparencyIndex = ~uint(0);
	if( !(mesh.flags & BVHMESH_FLAG_OPAQUE) )
	{
		transparencyIndex = rawLoad( RT_TransparencyIndices, h.objectIndex );
	}
	#endif

	if( intersectTriangleBVH( r, t, h ) && h.distance < hit.distance )
	{
		bool isHit = true;
		#if defined(RT_TRACE_CULL_BACKFACES)
		if( mesh.flags & BVHMESH_FLAG_CULL_BACKFACES )
		{
			vec3 N = cross( t.v1 - t.v0, t.v2 - t.v0 );
			isHit = dot( N, r.direction ) <= 0.0;
		}
		#endif
		#if defined(RT_TRACE_TRANSPARENCY)
		if( isHit )
		{
			isHit = testTransparencyBVH( t, h, transparencyIndex );
		}
		#endif
		#if defined(RT_TRACE_SUBSURFACE_DIFFUSION)
		if( isHit && h.hitIndices != uint(~0) )
		{
			uint currentHitIndex  = h.hitIndices & 0xFFFF;
			uint selectedHitIndex = h.hitIndices >> 16;
			isHit = ( currentHitIndex == selectedHitIndex );
			currentHitIndex++;
			h.hitIndices = (selectedHitIndex<<16) | currentHitIndex;
		}
		#endif

		if( isHit )
		{
			hit = h;
			#if defined(RT_TRACE_TERMINATE_ON_FIRST_HIT)
				BVH_RETURN_HIT;
			#endif
		}
		#if defined(RT_TRACE_TRANSPARENCY_DITHER) || defined(RT_TRACE_SUBSURFACE_DIFFUSION)
		else
		{
			#if defined(RT_TRACE_TRANSPARENCY_DITHER)
				//update RNG on miss so that subsequent alpha tests get new values
				hit.rng = h.rng;
			#endif
			#if defined(RT_TRACE_SUBSURFACE_DIFFUSION)
				//update hit indices on miss so that current hit index keeps increasing
				hit.hitIndices = h.hitIndices;
			#endif
		}
		#endif
	}
	BVH_RETURN_MISS;
}

vec2 intersectNodeBVH( Ray r, BVHNode node )
{
	vec4 boundsX = ( r.invDirection.x < 0.0 ) ? node.boundsX.yxwz : node.boundsX.xyzw;
	vec4 boundsY = ( r.invDirection.y < 0.0 ) ? node.boundsY.yxwz : node.boundsY.xyzw;
	vec4 boundsZ = ( r.invDirection.z < 0.0 ) ? node.boundsZ.yxwz : node.boundsZ.xyzw;

	vec3 ro = -r.origin * r.invDirection;

	vec2  t;
	vec3  slo, shi;
	float tmn, tmx;

	slo = mad( vec3( boundsX.x, boundsY.x, boundsZ.x ), r.invDirection, ro );
	shi = mad( vec3( boundsX.y, boundsY.y, boundsZ.y ), r.invDirection, ro );
	tmn = max( max( slo.x, slo.y ), slo.z );
	tmx = min( min( shi.x, shi.y ), shi.z );
	t.x = ( tmn <= tmx && tmx > 0.0 ) ? tmn : INFINITY;

	slo = mad( vec3( boundsX.z, boundsY.z, boundsZ.z ), r.invDirection, ro );
	shi = mad( vec3( boundsX.w, boundsY.w, boundsZ.w ), r.invDirection, ro );
	tmn = max( max( slo.x, slo.y ), slo.z );
	tmx = min( min( shi.x, shi.y ), shi.z );
	t.y = ( tmn <= tmx && tmx > 0.0 ) ? tmn : INFINITY;

	return t;
}

BVH_RESULT traverseBottomLevelBVH( uint groupIndex, Ray r, inout RayHit hit, uint meshIndex, uint submeshOffset )
{
	uint nodeIndex = 0;
	uint sp = 0;
	uint stack[64];

	BVHMesh mesh = loadMeshBVH(meshIndex);

	#ifdef RT_TRACE_MATCH_FLAGS
	if( !(mesh.flags & RT_TRACE_MATCH_FLAGS) )
	{
		BVH_RETURN_MISS;
	}
	#endif

	transformRay( mesh.inverseTransform, r );

	while( nodeIndex != ~uint(0) )
	{
		BVHNode node = RT_BVHNodes[mesh.nodeOffset + nodeIndex];
		nodeIndex = ~uint(0);
		
		vec2 tmin = intersectNodeBVH( r, node );

		HINT_FLATTEN
		if( tmin.y < tmin.x )
		{
			tmin.xy = tmin.yx;
			node.submeshIndex.xy = node.submeshIndex.yx;
			node.nodeRefIndex.xy = node.nodeRefIndex.yx;
		}

		if( tmin.x < hit.distance )
		{
			if( node.submeshIndex.x != ~uint(0) )
			{
				uint objectIndex   = submeshOffset + node.submeshIndex.x;
				uint triangleIndex = node.nodeRefIndex.x;
				BVH_TCALL( intersectLeafBVH( r, hit, mesh, objectIndex, triangleIndex ) );
			}
			else
			{
				nodeIndex = node.nodeRefIndex.x;
			}
		}
		if( tmin.y < hit.distance )
		{
			if( node.submeshIndex.y != ~uint(0) )
			{
				uint objectIndex   = submeshOffset + node.submeshIndex.y;
				uint triangleIndex = node.nodeRefIndex.y;
				BVH_TCALL( intersectLeafBVH( r, hit, mesh, objectIndex, triangleIndex ) );
			}
			else
			{
				if( nodeIndex == ~uint(0) )
				{
					nodeIndex = node.nodeRefIndex.y;
				}
				else
				{
					stack[sp++] = node.nodeRefIndex.y;
				}
			}
		}
		
		if( nodeIndex == ~uint(0) && sp > 0 )
		{
			nodeIndex = stack[--sp];
		}
	}
	BVH_RETURN_MISS;
}

BVH_RESULT traverseTopLevelBVH( uint groupIndex, Ray r, inout RayHit hit )
{
	uint nodeIndex = 0;
	uint sp = 0;
	uint stack[64];

	while( nodeIndex != ~uint(0) )
	{
		BVHNode node = RT_TopLevelBVH[nodeIndex];
		nodeIndex = ~uint(0);
		
		vec2 tmin = intersectNodeBVH( r, node );

		HINT_FLATTEN
		if( tmin.y < tmin.x )
		{
			tmin.xy = tmin.yx;
			node.submeshIndex.xy = node.submeshIndex.yx;
			node.nodeRefIndex.xy = node.nodeRefIndex.yx;
		}

		if( tmin.x < hit.distance )
		{
			if( node.submeshIndex.x != ~uint(0) )
			{
				BVH_TCALL( traverseBottomLevelBVH( groupIndex, r, hit, node.nodeRefIndex.x, node.submeshIndex.x ) );
			}
			else
			{
				nodeIndex = node.nodeRefIndex.x;
			}
		}
		if( tmin.y < hit.distance )
		{
			if( node.submeshIndex.y != ~uint(0) )
			{
				BVH_TCALL( traverseBottomLevelBVH( groupIndex, r, hit, node.nodeRefIndex.y, node.submeshIndex.y ) );
			}
			else
			{
				if( nodeIndex == ~uint(0) )
				{
					nodeIndex = node.nodeRefIndex.y;
				}
				else
				{
					stack[sp++] = node.nodeRefIndex.y;
				}
			}
		}
		
		if( nodeIndex == ~uint(0) && sp > 0 )
		{
			nodeIndex = stack[--sp];
		}
	}
	BVH_RETURN_MISS;
}

#ifdef RT_TRACE_OBJECTFILTER
bool traceRay( uint groupIndex, Ray r, float maxt, inout RayHit hit )
{
	hit.coords = vec2( 0.0, 0.0 );
	hit.distance = maxt;
	hit.triangleIndex = ~uint(0);
	hit.objectFilter = hit.objectIndex != ~uint(0);

	HINT_BRANCH
	if( hit.objectFilter )
	{
		BVHSubmesh submesh = RT_BVHSubmeshRefs[hit.objectIndex];
		traverseBottomLevelBVH( groupIndex, r, hit, submesh.meshIndex, submesh.submeshOffset );
	}
	else
	{
		traverseTopLevelBVH( groupIndex, r, hit );
	}

	HINT_FLATTEN
	if( hit.distance == maxt )
	{
		hit.distance = INFINITY;
	}
	return hit.distance < INFINITY;
}
#else
bool traceRay( uint groupIndex, Ray r, float maxt, inout RayHit hit )
{
	hit.coords = vec2( 0.0, 0.0 );
	hit.distance = maxt;
	hit.triangleIndex = ~uint(0);
	hit.objectIndex = ~uint(0);

	traverseTopLevelBVH( groupIndex, r, hit );

	HINT_FLATTEN
	if( hit.distance == maxt )
	{
		hit.distance = INFINITY;
	}
	return hit.distance < INFINITY;
}
#endif
