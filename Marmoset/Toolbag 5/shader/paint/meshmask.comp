#include "mesh.comp"

USE_LOADSTORE_BUFFER(uint, bOutput,0);			//output index buffer
USE_INTERLOCKED_BUFFER(bOutputIndex,1);		//index for our output buffer

uniform int uSparseData[DIVISIONS_X * DIVISIONS_Y];					//sparse data (1 byte per division)
uniform uint uWidth;		//just used for mapping thread IDs to tri index
uniform uint uIndexCount;
uniform uint uStartIndex;
uniform float uPadding;	//used when we need a more generous sparse mesh
COMPUTE(16, 16, 1)
{
	uint triIndex = DISPATCH_THREAD_ID.x + DISPATCH_THREAD_ID.y * uWidth;
	if(triIndex >= uIndexCount/3)
	{ return; }
	
	uint3 verts = loadTriangle( triIndex + uStartIndex/3 );
	Vertex v1 = loadVertex(verts.x);
	Vertex v2 = loadVertex(verts.y);
	Vertex v3 = loadVertex(verts.z);
	
	//TODO:  support UV outside of [0, 1]
	vec2 uvmin = saturate(min(v1.texcoord, min(v2.texcoord, v3.texcoord)) - uPadding);
	vec2 uvmax = saturate(max(v1.texcoord, max(v2.texcoord, v3.texcoord)) + uPadding);
	float eps = 0.0001;	//make sure we never end up at 1.0, or we'll overrun our array
	int2 imin = int2(uvmin.x * float(DIVISIONS_X) - eps, uvmin.y * float(DIVISIONS_Y) - eps);
	int2 imax = int2(uvmax.x * float(DIVISIONS_X) - eps, uvmax.y * float(DIVISIONS_Y) - eps);
	int hit = 0;
	bool visible = false;
	for(int y = imin.y; y <= imax.y; y++)
		for(int x = imin.x; x <= imax.x; x++)
		{
			if(uSparseData[x + (DIVISIONS_Y-1-y) * DIVISIONS_X] != 0)
			{ visible = true; }
		}
	
	//write out the visibility state of the tri and, if it's visible, increment the tri count buffer
	bOutput[triIndex] = uint(visible);
	if(visible)
	{
		uint prev;
		interlockedAdd( bOutputIndex, 0, 1, prev );	//increment our tri count buffer
	}
}
